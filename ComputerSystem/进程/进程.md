### 进程

#### 基础

资源分配调度；

##### 组成

- PCB
- 数据段
- 代码段

##### 状态

- 创建
    - 分配唯一的进程标识号（PID），并申请空白PCB；若分配失败，则创建失败；
    - 分配资源：程序 & 数据 & 用户栈分配分配必要的内存空间（PCB体现）；若资源不足，则阻塞态；
    - 初始化PCB：标志信息，处理机状态信息，处理机控制信息，进程优先级等；
    - 若进程就绪，添加入就绪队列等待调度；
- 运行
- 阻塞
- 就绪
- 结束

进程自身决定从运行态到阻塞态；

##### 切换

进程切换往往在调度完成后立刻发生：

保存原进程当前切换点的现场信息，恢复被调度进程的现场信息

- 操作系统内核将原进程的现场信息推入当前进程的内核堆栈保存并更新堆栈指针；
- 从新进程的内核栈中装入新进程的现场信息，更新进程空间指针，重设PC寄存器等工作后开始执行新进程；

>在每一个进程的生命周期中，经常会通过系统调用（SYSCALL）陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先用户空间中的栈，而是一个内核空间的栈，这个称作进程的“内核栈”;
>
>Linux 中 每个task的栈分成用户栈和内核栈两部分，进程内核栈定义：
>
>```c
>union thread_union {
>	struct thread_info thread_info;
>	unsigned long stack[THREAD_SIZE/sizeof(long)];
>};
>```



##### 通信

- 共享存储

    - 基于数据结构
    - 基于存储区

- 消息传递

    - 直接
    - 间接

- 管道通信

    存在于内存中，通常为一页；



每个进程均有用户堆栈和系统堆栈

- 用户堆栈：保存用户进程子程序间相互调用的参数（返回地址 及 子程序的局部变量）
- 系统堆栈：
    - 保存中断现场，嵌套中断时，被中断程序的现场信息依次压入；
    - 保存操作系统子程序间相互调用的参数、返回值及局部变量；