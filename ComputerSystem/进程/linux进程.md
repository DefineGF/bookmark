#### Linux 进程模型

##### 私有地址空间

- 地址空间底部保留给用户程序：
    - 代码段：从 0x400000开始
        - 只读代码段
        - 读写段
    - 运行时堆：由malloc创建
    - 共享库的内存映射区域
    - 用户栈：运行时创建
- 地址空间顶部保留给内核：包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和段；



##### 上下文切换

内核为每个进程维持一个上下文，保存了北河重启一个被抢占的进程所需要的状态：

- 通用目的寄存器
- 浮点寄存器
- 程序计数器
- 用户栈
- 状态寄存器
- 内核栈
- 各种内核数据结构
    - 页表：描述地址空间
    - 进程表：包含当前进程信息
    - 文件表：包含进程打开文件的信息

过程：

1. 保存当前进程的上下文；
2. 恢复某个先前被抢占的进程保存的上下文；
3. 将控制传递给这个新恢复的进程；

##### 创建子进程

```c
#include <sys/types.h>
#include <unistd.h>

int main()
{
	pid_t pid;
	int x =1;
	pid = Fork();
	if (pid == 0) { // 子进程
		printf("child: x = %d \n", ++x); // 2
		exit(0);
	}
	printf("parent: x = %d \n",--x); // 0
}
```

Fork() 子进程返回 0；创建失败返回 -1；

- 子进程得到与父进程用户级虚拟地址空间相同（但是独立）的副本，包括代码段、数据段、堆、共享库和用户栈；独立例子比如 上述中的 变量 x，可以理解为深拷贝；
- 同时获得与父进程文件描述符相同的副本，意味着父进程调用fork时，子进程可以读写父进程打开的任何文件；
- 并发执行，内核可以能够以任何方式交替执行让它们的逻辑控制流中的指令；



##### 回收子进程

- 子进程终止时，内核并不是立即把他从系统中清除，而是保持已终止的状态，直到它父进程被回收；一个已终止但是未回收的进程称之为僵死进程；

- 父进程终止，但是子进程仍在执行，称之为孤儿进程；内核会安排init进程称为孤儿进程的养父。

    init进程PID = 1，在系统启动时由内核创建，不会终止，是所有进程的祖先。