### 线程安全

#### 互斥同步（阻塞同步）

同步：多个线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程使用；

互斥是实现同步的手段，常用的有：

- 临界区
- 互斥量
- 信号量

java中最常用的是 synchronized 关键字：

- 对同一线程来说是可重入的；
- 阻塞后面其他进程的进入；

主要问题：

java的线程是映射到操作系统上的原生线程之上；如果阻塞和唤醒一个线程，都需要操作系统完成（用户态\核心态）；

互斥同步的最主要问题就是进行线程阻塞和唤醒带来的性能问题；需要加锁、用户态核心态转换，维护所计数器和检查是否有被阻塞的线程需要唤醒等；



#### 非阻塞同步

基于冲突检测的乐观并发策略：

先进行操作，如果没有其他线程争用共享数据，那操作就成功了；

若共享数据有争用，产生了冲突，那就采取其他补偿措施（常用不断重试直到成功）

##### 条件

操作和冲突检测具有原子性，需要硬件指令集的发展；

- 测试并设置（Test-and-Set）
- 获取并增加（Fetch-and-Increment）
- 交换（Swap）
- 比较并交换（Compare-and-Swap）
- 加载链接/条件存储（Load-Linked/Store-Conditional, LL/SC)



##### CAS

操作数：

- 内存位置（java中可理解为变量的内存地址 V）
- 旧的预期值（用A表示）
- 新值（用B表示）

当且仅当V位置上的旧值符合A时，处理器用新值B更新V值；否则就不更新。同时返回旧值。

```java
// AutomicInteger
public final int incrementAndGet() {
	for(;;) {
		int current = get();
		int next = current + 1;
		if (compareAndSet(current, next)) 
			return next;
	}
}
```

incrementAndGet() 不断尝试一个比当前值大于1的新值赋给自己；

ABA问题：

初始值为A，中途修改为B，其后再修改为A；那么CAS会认为它从来没有修改过；

J.U.C 提供带有原子引用类的 AtomicStampedReference 通过控制变量值的版本来保证CAS的正确性；

（大部分情况下 ABA不会影响程序并发的正确性）



##### 可重入代码

纯代码；可在代码执行的任何时刻中断他，转而执行另一段代码；获得控制权返回后，原来的程序不会发生任何错误。

特征：

不依赖存储在堆上的数据和公用的系统资源；用的状态量都有参数中传入、不调用非可重入的方法等；



##### 线程本地存储

把共享数据的可见范围限制在同一个线程中，无需同步也能保证线程之间不出现数据争用的问题









