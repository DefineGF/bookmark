#### 如何定位垃圾

1. 引用计数

    不适用于循环引用

2. 根可达性算法

     

#### 常见垃圾回收算法

1. 标记清除：产生碎片
2. 拷贝算法：空间利用率低
3. 标记压缩：效率低

#### 内存分代模型

1. 部分垃圾回收器使用的模型
2. 新生代 + 老年代 + 永久代（1.7）/ 元数据区（1.8）
     1. 永久代 元数据 -Class
     2. 永久代有大小限制， 元数据可有可无（受制于物理内存)
    3. 字符串常量1.7 -永久代， 1.8 - 堆

3. 新生代 = Eden + 2 * survivor
4. 老年代
    1. 顽固分子
    2. 满了触发FGC
5. 尽量减少FGC



#### 对象创建

虚拟机遇到new关键字，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用 && 此符号引用代表的类是否被加载、解析、初始化过；

​	若没有：执行类加载，类加载完成后可确定对象所需的内存。



堆中内存绝对规整，用指针分割空闲和用过内存，分配采用“指针碰撞”；

内存并非规整，虚拟机维护一个列表，分配方式为“空闲列表”；



##### 引用

 ![1613009043233](F:\Typora\Nodes\java\JVM\GC\1613009043233.png)

##### 内存泄漏

​	主要原因是存在无效的引用，导致本来需要被GC的对象没有被清除；

##### 内存溢出

​	申请的内存超出了虚拟机能分配的内存；



注：在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用**软引用和弱引用**技术



