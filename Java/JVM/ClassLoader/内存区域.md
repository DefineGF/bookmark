### 内存区域

 ![1613007563317](F:\Typora\Nodes\java\JVM\1613007563317.png)



#### java堆

- **所有线程共享**；内存中最大的一块；

- 物理上可不连续，逻辑上连续；
- 只存放对象实例（几乎所有对象都在这里分配，当然还有小部分栈上分配、标量替换优化技术）；
- 垃圾管理器主要区域；

从内存回收角度：

​	现代收集器基本采用分代收集算法，故堆可分为新生代和老年代；

从内存分配角度：

​	多个线程私有的分配缓冲区；



#### 方法区

- 所有线程共享

- 存储**已被虚拟机加载的类的信息，常量，静态变量（也成为类变量），即时编译器编译后的代码等**

    - 类信息：类版本，字段，方法，接口

- 包含 **运行时常量池**

    用于存放编译期生成的各种**字面量和符号引用**，在类加载后进入方法区时称**运行时常量池**；

    运行期间也有可能将信息的常量放入池中:

    ​	比如String intern // 表示返回字符串规范化表示形式，人话就是指向线程池中常量

    ```java
    String s1 = "Java";//其中Java字符串位于常量池中
    
    //创建对象时，先检查常量池中有无"Java"，然后在堆内存中创建String对象，并指向常量池中数据
    String s2 = new String("Java");
    String s3 = new String("Java");//此时s2 == s3;为false，两者指向的堆内存地址不同
    s3.intern() == s1; // true
    ```

    



#### 虚拟机栈

##### 栈帧

- 局部变量表

    编译期可知的各种基本数据类型，对象引用类型。

    当线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError；

    若可扩展且扩展时无法申请到足够的内存，抛出OutOfMemoryError；

- 操作数栈

- 动态链接

- 返回地址

线程私有，生命周期与线程相同；

虚拟机栈为虚拟机执行java（字节码）服务；

**每个方法执行同时**，都会创建一个**栈帧**用于存储**局部变量表，操作数栈，动态链接，方法出口等**；



#### 本地方法栈

虚拟机执行Native方法服务，其余相似于java虚拟机栈;



#### 程序计数器

java虚拟机多线程通过线程轮流切换并分配处理器运行时间来实现的；

任何确定时刻，一个处理器（多核处理器来说是一个内核）都只会执行一条线程中的指令。

为了恢复，**每个线程**都需要一个独立（各线程之间计数器互不影响相互存储，线程私有）的程序计数器。



#### 直接内存

并非虚拟机运行时数据区的一部分，但是也频繁使用；

NI/O类，基于通道与缓冲区的I/O方式，使用Native库直接分配堆外内存；



#### 总结

![1613008831519](F:\Typora\Nodes\java\JVM\1613008831519.png)

